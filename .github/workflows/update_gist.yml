name: YouTube Live to Gist Multi-Manifest

on:
  schedule:
    - cron: "*/5 * * * *"
  workflow_dispatch: {}

permissions:
  contents: read

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: pip install --upgrade yt-dlp requests

      - name: Prepare cookies
        env:
          COOKIES_CONTENT: ${{ secrets.YT_COOKIES }}
        run: |
          if [ -n "$COOKIES_CONTENT" ]; then
            echo "$COOKIES_CONTENT" > cookies.txt
          fi

      - name: Normalize channels.txt
        run: |
          if [ -f channels.txt ]; then
            tr -d '\r' < channels.txt > channels_unix.txt && mv channels_unix.txt channels.txt
          else
            echo "‚ö†Ô∏è channels.txt bulunamadƒ±!" && exit 1
          fi

      - name: Update Gist manifests (each channel separate)
        env:
          GIST_ID: ${{ secrets.GIST_ID }}
          GIST_TOKEN: ${{ secrets.GIST_TOKEN }}
        run: |
          set -e
          PY=$(cat <<'PYCODE'
import os, subprocess, json, requests

gist_id = os.getenv("GIST_ID")
gist_token = os.getenv("GIST_TOKEN")
cookies_file = "cookies.txt" if os.path.exists("cookies.txt") else None

def run_cmd(cmd):
    try:
        return subprocess.check_output(cmd, text=True).strip()
    except subprocess.CalledProcessError:
        return ""

def get_video_id(channel):
    url = f"https://www.youtube.com/{channel}/live" if not channel.startswith("UC") else f"https://www.youtube.com/channel/{channel}/live"
    base_cmd = ["yt-dlp", "--no-warnings", "--skip-download", "--print", "%(is_live)s %(id)s"]
    if cookies_file: base_cmd += ["--cookies", cookies_file]
    out = run_cmd(base_cmd + [url])
    if "True" in out:
        return out.split()[-1]
    return None

def get_streams(video_id):
    cmd = ["yt-dlp", "--no-warnings", "--skip-download", "-F", f"https://www.youtube.com/watch?v={video_id}"]
    if cookies_file: cmd += ["--cookies", cookies_file]
    formats = run_cmd(cmd)
    lines = [l for l in formats.splitlines() if "video only" in l or "audio only" in l or "m3u8" in l]
    return lines

def get_url(video_id, height):
    fmt = f"bestvideo[height<={height}]+bestaudio/best[height<={height}]/best"
    cmd = ["yt-dlp", "--no-warnings", "--skip-download", "-f", fmt, "--get-url", f"https://www.youtube.com/watch?v={video_id}"]
    if cookies_file: cmd += ["--cookies", cookies_file]
    return run_cmd(cmd).splitlines()[0] if run_cmd(cmd) else None

def update_gist_file(name, content):
    api = f"https://api.github.com/gists/{gist_id}"
    payload = {"files": {name: {"content": content}}}
    headers = {"Authorization": f"token {gist_token}"}
    r = requests.patch(api, headers=headers, data=json.dumps(payload))
    print(f"üîÑ Updated {name} ‚Üí {r.status_code}")

def main():
    with open("channels.txt", "r", encoding="utf-8") as f:
        for line in f:
            line=line.strip()
            if not line or line.startswith("#"): continue
            parts = line.split(",")
            if len(parts) < 2: continue
            handle, gistfile = parts[0].strip(), parts[1].strip()
            print(f"‚ñ∂ Processing {handle} ‚Üí {gistfile}")

            vid = get_video_id(handle)
            if not vid:
                print(f"‚ùå {handle}: No live stream")
                continue

            print(f"üé• Live ID: {vid}")
            qualities = [144, 240, 360, 480, 720, 1080]
            lines = ["#EXTM3U", "#EXT-X-VERSION:3"]
            for q in qualities:
                url = get_url(vid, q)
                if url:
                    lines.append(f"#EXT-X-STREAM-INF:BANDWIDTH={q*1000},RESOLUTION={q}p")
                    lines.append(url)
            manifest = "\n".join(lines)
            update_gist_file(gistfile, manifest)
            print(f"‚úÖ {gistfile} updated")

if __name__ == "__main__":
    main()
PYCODE
)
          echo "$PY" > updater.py
          python3 updater.py
